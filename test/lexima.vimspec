Describe lexima's

  After all
    new
    only!
  End

  After each
    %delete _
  End

  Context default rules

    Before all
      call lexima#init()
    End

    It automatically inputs pair parentheses
      execute "normal aHOGE(FUGA(PIYO\<Esc>"
      call Expect(['HOGE(FUGA(PIYO))']).to_be_displayed()
      execute "normal I(\<Esc>"
      call Expect(['()HOGE(FUGA(PIYO))']).to_be_displayed()
    End

    It can repeat with dots
      execute "normal oHOGE(FUGA(PIYO\<Esc>"
      normal! ..
      call Expect(['', 'HOGE(FUGA(PIYO))', 'HOGE(FUGA(PIYO))', 'HOGE(FUGA(PIYO))']).to_be_displayed()
    End

    It can input closing parenthesis
      execute "normal i)\<Esc>"
      call Expect(')').to_be_displayed()
    End

    It can leave at end of parenthesis
      execute "normal iHOGE(FUGA(PIYO))\<Esc>"
      call Expect(['HOGE(FUGA(PIYO))']).to_be_displayed()
    End

    It can leave at end of parenthesis2
      execute "normal iHOGE(FUGA(PIYO), x(y\<Esc>"
      call Expect('HOGE(FUGA(PIYO), x(y))').to_be_displayed()
    End

    It with leave can repeat with dots
      execute "normal oHOGE(FUGA(PIYO), x(y\<Esc>"
      normal! ..
      call Expect(['', 'HOGE(FUGA(PIYO), x(y))', 'HOGE(FUGA(PIYO), x(y))', 'HOGE(FUGA(PIYO), x(y))', ]).to_be_displayed()
    End

    It with leave can repeat with dots2
      for i in range(1, 3)
        call setline(i, '12345')
      endfor
      normal! gg2|
      execute "normal aHOGE(FUGA(PIYO), x(y\<Esc>"
      normal! j0.
      normal! j$.
      call Expect(['12HOGE(FUGA(PIYO), x(y))345', '1HOGE(FUGA(PIYO), x(y))2345', '12345HOGE(FUGA(PIYO), x(y))', ]).to_be_displayed()
    End

    It can repeat if CR input
      execute "normal oHOGE(\<CR>\<Esc>"
      normal! ..
      call Expect(['', 'HOGE(', ')', 'HOGE(', ')', 'HOGE(', ')']).to_be_displayed()
    End

    It can repeat if CR input with set smartindent
      setlocal smartindent
      execute "normal oHOGE(\<CR>\<Esc>"
      normal! ..
      call Expect(['', 'HOGE(', ')', 'HOGE(', ')', 'HOGE(', ')']).to_be_displayed()
      setlocal smartindent&
    End

    It automatically inputs pair braces with newline
      execute "normal aHOGE({\<CR>FUGA{\<CR>PIYO{\<CR>\<Esc>"
      call Expect(['HOGE({', 'FUGA{', 'PIYO{', '', '}', '}', '})']).to_be_displayed()
    End

    It automatically inputs pair braces with newline and set smartindent
      setlocal smartindent
      execute "normal aHOGE({\<CR>FUGA{\<CR>PIYO{\<CR>\<Esc>"
      call Expect(['HOGE({', "\tFUGA{", "\t\tPIYO{", '',  "\t\t}", "\t}", '})']).to_be_displayed()
      setlocal smartindent&
    End

    It automatically inputs pair braces with newline and set indentexpr
      setlocal ft=ruby et sw=2
      execute "normal amodule Hoge\<CR>def piyo\<CR>foo {\<CR>\<Esc>"
      call Expect(['module Hoge', '  def piyo', '    foo {', '', '    }']).to_be_displayed()
      setlocal ft= et& sw&
    End

    It can move the cursor
      execute "normal aHOGE(\"FUGA\<Right>\<Right>\<Esc>"
      call Expect(['HOGE("FUGA")']).to_be_displayed()
    End

  End

  " function! s:suite.__leave_rules__()
  "   let leave_rule = themis#suite('leave rules')

  "   function! leave_rule.before()
  "     call lexima#clear_rules()
  "     call lexima#add_rule({'char': '(', 'input_after': ')'})
  "     call lexima#add_rule({'char': '*', 'at': '(\%#)', 'input_after': '*'})
  "     call lexima#add_rule({'char': '*', 'at': '\%#\*)', 'leave': 1})
  "     call lexima#add_rule({'char': ')', 'at': '\%#\*)', 'leave': 2})
  "   End

  "   function! leave_rule.before_each()
  "     %delete _
  "   End

  "   function! leave_rule.can_leave_one()
  "     execute "normal i(**;\<Esc>"
  "     call Expect(['(**;)']).to_be_displayed()
  "   End

  "   function! leave_rule.can_leave_two()
  "     execute "normal i(*);\<Esc>"
  "     call Expect(['(**);']).to_be_displayed()
  "   End

  " End

  Context leave rules

    Before all
      setlocal nocindent smartindent
    End

    Before each
      call lexima#clear_rules()
      call lexima#add_rule({'char': '{', 'input_after': '}'})
      call lexima#add_rule({'char': '*', 'at': '{\%#}', 'input_after': '*'})
    End

    It can leave one
      call lexima#add_rule({'char': '*', 'at': '\%#\*}', 'leave': 1})
      execute "normal i{**;\<Esc>"
      call Expect(['{**;}']).to_be_displayed()
    End

    It can leave two
      call lexima#add_rule({'char': '}', 'at': '\%#\*}', 'leave': 2})
      execute "normal i{*};\<Esc>"
      call Expect(['{**};']).to_be_displayed()
    End

    It can leave till specified char
      call lexima#add_rule({'char': '}', 'at': '\%#\*}', 'leave': '}'})
      execute "normal i{*};\<Esc>"
      call Expect(['{**};']).to_be_displayed()
    End

    It can leave over cr
      call lexima#add_rule({'char': '<CR>', 'at': '{\%#}', 'input_after': '<CR>'})
      call lexima#add_rule({'char': '}', 'leave': 1})
      execute "normal i{\<CR>;}\<Esc>"
      call Expect(['{', "\t;", '}']).to_be_displayed()
    End

    It can leave till specified char over cr
      call lexima#add_rule({'char': '<CR>', 'at': '{\%#}', 'input_after': '<CR>'})
      call lexima#add_rule({'char': '}', 'leave': '}'})
      execute "normal i{\<CR>;}\<Esc>"
      call Expect(['{', "\t;", '}']).to_be_displayed()
    End

    It can leave till specified char over cr
      call lexima#add_rule({'char': '<CR>', 'at': '{\%#}', 'input_after': '<CR>'})
      call lexima#add_rule({'char': '}', 'leave': '}'})
      execute "normal o{\<CR>{\<CR>hoge{}}\<Esc>"
      normal! .
      call Expect(['', '{', "\t{", "\t\thoge{}", "\t}", '}', '{', "\t{", "\t\thoge{}", "\t}", '}']).to_be_displayed()
    End

    It can leave till end of line
      call lexima#add_rule({'char': '"', 'input_after': '"'})
      call lexima#add_rule({'char': '<CR>', 'at': '{\%#}', 'input_after': '<CR>'})
      call lexima#add_rule({'char': '}', 'leave': '}'})
      execute "normal o{\<CR>{\<CR>hoge{\"foo{\<C-r>=lexima#leave_till_eol('')\<CR>;\<Esc>"
      call Expect(['', '{', "\t{", "\t\thoge{\"foo{}\"};", "\t}", '}']).to_be_displayed()
      normal! .
      call Expect(['', '{', "\t{", "\t\thoge{\"foo{}\"};", "\t}", '}', '{', "\t{", "\t\thoge{\"foo{}\"};", "\t}", '}']).to_be_displayed()
    End

  End

  Context filetype rules
    let ft_rule = themis#suite('filetype rules')

    Before all
      call lexima#clear_rules()
      let s:save_default_rules = g:lexima#default_rules
      let g:lexima_no_default_rules = 1
      call lexima#add_rule({'char': '(', 'input_after': ')'})
      call lexima#add_rule({'char': '(', 'input_after': 'Ruby!)', 'filetype': 'ruby'})
      call lexima#add_rule({'char': '(', 'input_after': 'Java script?)', 'filetype': 'javascript'})
    End

    It is triggered in suitable filetype
      execute "normal i(\<Esc>"
      call Expect(['()']).to_be_displayed()
      enew!
      setlocal filetype=ruby
      execute "normal i(\<Esc>"
      call Expect(['(Ruby!)']).to_be_displayed()
      enew!
      setlocal filetype=javascript
      execute "normal i(\<Esc>"
      call Expect(['(Java script?)']).to_be_displayed()
    End

    It falls back to default rule
      setlocal filetype=ocaml
      execute "normal i(\<Esc>"
      call Expect(['()']).to_be_displayed()
    End

  End

  Context syntax rules

    Before all
      call lexima#clear_rules()
      let s:save_default_rules = g:lexima#default_rules
      let g:lexima_no_default_rules = 1
      call lexima#add_rule({'char': '"', 'input_after': '"'})
      call lexima#add_rule({'char': '%', 'input': '%%', 'syntax': 'String'})
      setlocal filetype=vim
    End

    It is triggered in suitable syntax
      execute "normal ilet x = %\"%\<Esc>"
      call Expect(['let x = %"%%"']).to_be_displayed()
    End

  End

  Context commandline mappings

    Before all
      call lexima#clear_rules()
      call lexima#add_rule({'char': '(', 'input': '{', 'input_after': '}', 'mode': 'c'})
      command -nargs=* Test let g:cmdline_mappings_input = <q-args>
      call themis#helper#expect#define_matcher('to_change_to', 'g:cmdline_mappings_input ==# a:2', '"Expected " . g:cmdline_mappings_input . " to change to " . a:2')
    End

    function! CmdlineInput(str)
      execute "normal :Test " . a:str . "\<CR>"
      return a:str
    endfunction

    It works well
      call Expect(CmdlineInput("(")).to_change_to("{}")
    End

    It does not affect on insertmode
      execute "normal ihoge(\<Esc>"
      call Expect(['hoge(']).to_be_displayed()
    End

  End
End
